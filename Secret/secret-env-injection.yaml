apiVersion: v1
kind: Secret
metadata:
  name: webapp-secret
type: Opaque
stringData:
  # Using stringData for readability (auto-converts to base64)
  database_password: "supersecret123"
  api_token: "abcd1234-efgh-5678-ijkl-9012mnop3456"
  redis_password: "redis-secret-pass"
  jwt_secret: "my-jwt-signing-secret-key"
---
apiVersion: v1
kind: Pod
metadata:
  name: secret-env-demo
spec:
  containers:
  - name: webapp
    image: nginx:alpine
    ports:
    - containerPort: 80
    # METHOD 1: Inject specific Secret keys as environment variables
    env:
    - name: DB_PASSWORD # Environment variable name in pod
      valueFrom:
        secretKeyRef:
          name: webapp-secret # Secret name
          key: database_password # Key from Secret
    - name: API_TOKEN
      valueFrom:
        secretKeyRef:
          name: webapp-secret
          key: api_token
          optional: true # Pod starts even if key doesn't exist
    # METHOD 2: Inject ALL Secret keys as environment variables
    envFrom:
    - secretRef:
        name: webapp-secret # All keys become env vars
        # Keys like "jwt_secret" become "jwt_secret" env var

        # METHOD 3: Mount Secret as volume (files in filesystem)
    volumeMounts:
    - name: secret-volume
      mountPath: /etc/secrets # Directory where files will be mounted
      readOnly: true
    - name: specific-secret-volume
      mountPath: /etc/ssl/private/jwt-secret
      subPath: jwt_secret # Mount specific key as file
      readOnly: true
  # Image pull secret (automatically used for private registries)
  imagePullSecrets:
  - name: regcred # Docker registry secret name

  volumes:
  # Volume for METHOD 3: Mount entire Secret as directory
  - name: secret-volume
    secret:
      secretName: webapp-secret # Secret name
      # Each key becomes a file, value becomes file content (decoded)
      # Files: database_password, api_token, redis_password, jwt_secret

      # Volume for METHOD 3: Mount specific Secret key as file
  - name: specific-secret-volume
    secret:
      secretName: webapp-secret
      items:
      # Specify which keys to mount
      - key: jwt_secret # Key from Secret
        path: jwt_secret # Filename in pod
        mode: 400 # File permissions (read-only for owner)
      defaultMode: 400 # Default file permissions
      optional: false # Pod fails if Secret doesn't exist
---
# Example: Using multiple Secrets in same pod
apiVersion: v1
kind: Pod
metadata:
  name: multiple-secrets-demo
spec:
  containers:
  - name: app
    image: busybox
    command: [ "sleep", "3600" ]

    # Mix environment variables from different sources
    env:
    # From specific Secret keys
    - name: DB_PASS
      valueFrom:
        secretKeyRef:
          name: webapp-secret
          key: database_password
    # From all keys in Secret
    envFrom:
    - secretRef:
        name: webapp-secret
    - secretRef:
        name: another-secret # Can include multiple Secrets

    volumeMounts:
    # Mount multiple Secrets as separate directories
    - name: webapp-secret-vol
      mountPath: /etc/webapp-secrets
    - name: tls-secret-vol
      mountPath: /etc/ssl/certs

  volumes:
  - name: webapp-secret-vol
    secret:
      secretName: webapp-secret
  - name: tls-secret-vol
    secret:
      secretName: tls-secret # TLS certificate secret
---
# CKAD Exam Scenario: Environment-specific Secrets
apiVersion: v1
kind: Secret
metadata:
  name: db-secret-dev
  labels:
    environment: development
type: Opaque
stringData:
  username: "dev-user"
  password: "dev-password"
  host: "dev-mysql.development.svc.cluster.local"
---
apiVersion: v1
kind: Secret
metadata:
  name: db-secret-prod
  labels:
    environment: production
type: Opaque
stringData:
  username: "prod-user"
  password: "prod-secure-password-123"
  host: "prod-mysql.production.svc.cluster.local"
